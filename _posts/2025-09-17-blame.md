---
title: A kludgy new way to git-blame
tags: [ git ]
category: [ Blog ]
---

Lately I find myself feeding `git grep` results to `git blame` to help identify
points of contact for a piece of code. I've scripted a few hacks together to
make life easier.

**Call for help:** If you have ideas on how to better parse `git grep` output or
feed it to `git blame`, please let me know [on
GitHub](https://github.com/benknoble/Dotfiles/) or in the comments.

When I'm interested in who to talk to about a small chunk of code, I usually
navigate to it in Vim and run [`:Git
blame`](https://github.com/tpope/vim-fugitive/blob/61b51c09b7c9ce04e821f6cf76ea4f6f903e3cf4/doc/fugitive.txt#L57).
I might also throw the file or containing directory at `git shortlog` to get a
sense of who's active in the area.

My current `$DAYJOB` includes working with a large monorepo, and I frequently
have questions of the form "who should I ask about feature X that cuts across
many different code modules?"---in such a situation, I've recently been piping
`git grep` into `git blame`. (Feeding `git grep --files-with-matches` into `git
shortlog` is not awful, but typically gives too many contacts.)

The trouble is, each time I've done this I've had to recraft the pipeline. Often
it's some variant[^1] of

```shell
git grep … | fields -f: 1 2 | xargs -L1 sh -c 'git blame -L$1,$1 $0'
```

This doesn't quite work correctly if I grep a specific revision. When I'm on a
topic branch and a teammate has a question, I might do

```shell
git f # short for fetch, and I have fetch.all=true configured
git grep … origin | fields -f: {1..3} | xargs -L1 sh -c 'git blame -L $2,$2 $1 $0'
```

Argh! And, although I haven't lifted this limitation in my script, if I throw
`-C`-style context results in there, this won't work. If we get binary matches,
this won't work. Etc.

I got tired of trying to get this right interactively and figured I'd capture
the whole thing as a script. So let's start with that.

## `git-greb`: blame matching lines

If `grep` comes from `:g/re/p` in `ed(1)`, then `greb` is the natural extension
to a "b for blame" verb.

The [initial version of the
script](https://github.com/benknoble/Dotfiles/commit/68002c7e705a1bb383160d09a89b57a858d9268d)
works for the main use cases above:

```
git greb …
git greb -r origin -- …
```

Yahoo! And if I need to build more "blame input from X" tools, I now have `git
blame-stdin` as plumbing I can re-use. That saves me from reconstructing
different `fields … | xargs …` pipelines.

Further, `git greb` supports most of the grep flags I care about for this sort
of search.

However, let's talk about the ugly…

## `git grep` is not designed for machine consumption

In fact, `git grep` seems to go out of it's way to avoid being useful as input
to a script! Let's see if I can explain how: config and command line options can
dramatically affect output formats, which is tough to handle if you want to
support most `git grep` invocations. I originally planned for `git greb` to be
as easy as running `git grep …`, then `^p^b` in my shell would turn that into
`git greb …`. Alas, not so. Some examples of what goes wrong:

- We want to keep line numbers for effective blaming, so anything that changes
  that format is out. That mean `-h`, `-l`, `-c`, etc.
- We don't want to try to open files in the pager, but that was never going to
  be supported. Still, we have to reject that option.
- Various options throw other noise into the output (`--break`, `--heading`).
- None of the context options (`-A`, `-B`, `-C`, `-p`, `-W`) use the same
  `file:line` formatting, so we can't use them at all (or we have to try to
  parse all possible formats, of which there are several, without screwing
  things up when a filename contains a hyphen or equals sign; we're already
  screwed if a filename contains a colon).
- And finally: `-z` for nul-delimited output _still isn't sufficient_: we do get
  `file<nul>line<nul>`, the revision (if present) is prepended with `rev:`. But
  I can't guarantee that doesn't contain a colon, since `:/post:` is a valid
  revision (at least on this website's code) and is displayed as typed! Further,
  parsing nul-delimited lines in a shell script is fraught.

I was originally planning to support non-trivial filenames, but it quickly
became too much work. So for now, I'm supporting filenames that don't have to be
escaped without `-z`, and that don't contain a colon. I'm also explicitly
rejecting any unsupported `git grep` option to make things easier.

## `git greb`'s interface is ugly

Yeah. Because of all the munging above, and because I need to feed a revision to
`git blame` when one is present but not have ambiguous parsing that sometimes
gets it wrong, I have `git-greb` take a `--revision <rev>` flag. But if it has
flags, it has to delimit between its flags and `git-grep`'s flags. That's the
first `--` in its synopsis. (If you don't use any options, you don't need it.)

_Then_, I need to reinsert the revision at the end of the `git grep` command
(but before any pathspecs), so if you provide a pathspec and a revision you
_must_ give the second `--` to separate the pathspec from the previous
arguments. Ugh. (The code isn't particularly pretty, either.)

At least I had the foresight to include `-v` as a debugging aid in both scripts:
that's my way[^2] of having scripts output the Git commands they run, which is
also useful when I share the outputs with other folks so they can see what I
did.

## Notes

[^1]: [My fields script is described on this blog]({% link _posts/2019-09-11-fields.md %}).
[^2]: My [`git-div` script]({% link _posts/2024-11-15-useful-utilities.md %}#git) was my first to support this.
