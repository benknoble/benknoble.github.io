<!DOCTYPE html>
<html>
  <head>
  <title>Junk Drawer : Perspective on software development models</title>
  <meta charset='utf-8'>
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  <!-- link to main stylesheet -->
  <link rel="stylesheet" type="text/css" href="https://benknoble.github.io/assets/css/styles.css" media="screen">

  <script src="/assets/js/scale.fix.js"></script>
  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" >
  </script>

  <link rel="apple-touch-icon" sizes="180x180" href="/assets/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/assets/img/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">

  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link type="application/atom+xml" rel="alternate" href="https://benknoble.github.io/feed.xml" title="Junk Drawer" />
</head>

  <body>
    <header>
  <h1>
  <a href="https://benknoble.github.io/">
  <img src='/assets/img/logo.png' alt='Junk Drawer Logo' width=32 height=32> Junk Drawer</a></h1>
  <p>For all those little papers scattered across your desk</p>
</header>

    <section>
      <nav>
  <ul>
    
    <li class="">
      <a href="https://benknoble.github.io/about/">About</a>
    </li>
    
    <li class="">
      <a href="https://benknoble.github.io/categories/">Posts</a>
    </li>
    
    <li class="">
      <a href="https://benknoble.github.io/workshops/">Workshops</a>
    </li>
    
    <li class="">
      <a href="https://benknoble.github.io/papers/">Papers</a>
    </li>
    
    <li class="">
      <a href="https://benknoble.github.io/writings/">Writings</a>
    </li>
    
    <li class="">
      <a href="https://benknoble.github.io/reading/">Reading List</a>
    </li>
    
  </ul>
</nav>

      <h1>Perspective on software development models</h1>
      <p class="meta"><span class="authors">
  
  
    D. Ben Knoble
  
</span>
 on 11 Nov 2024 in Blog</p>
<div id="post">
  <p><strong>Update 2024 November 22: I may have some misunderstandings about trunk-based
development, and this article needs a (as-of-yet incomplete) rewrite as a
result.</strong></p>

<p>If I believe <a href="/about/#me">simple questions have complex answers</a>, then it’s no surprise that I have a complicated take on the following
question: branch-based or trunk-based development? Which is better, and why?</p>

<p>As usual, though, <em>we’re asking the wrong questions.</em> For spoilers, jump to the
<a href="#conclusion">conclusion</a>.</p>

<h2 id="impetus-opinion-and-advantage-without-mechanism-or-goal">Impetus: opinion and advantage without mechanism or goal</h2>

<p>Part of this post is a reply to posts like <a href="https://trishagee.com/2023/05/29/why-i-prefer-trunk-based-development/">Trisha Gee’s “Why I prefer
trunk-based
development”</a>.
If you don’t care for musings on that, skip to <a href="#analysis">the beginning of my
analysis</a> for the rest of the post, which examines the tradeoffs of
branch-based and trunk-based development in light of 5 pillars.</p>

<p>Gee outshines many of her peers with her titular framing: the article explores
<em>her</em> preferences based on <em>her</em> experience. Too many answers to the question
of “to branch or not to branch” want to convince you of their absolute
correctness, shades of gray be damned. And if that kind of extreme conviction
sets off your spidey senses, it’s time to double-check: are the authors of such
answers trying to sell you something?</p>

<p>Others repeat tired claims, often without evidence. This is cargo-cult
programming and should be approached with the same skepticism: <a href="https://chelseatroy.com/2022/04/18/best-practice-is-not-a-reason-to-do-something/">“Best Practice”
is not a reason to do something</a>.</p>

<p>Gee stands out, then, for speaking personally and from professional experience.
Her introduction winds you up for a “when I was at X and we did Y, we found Z”
tale. These stories form the basis of mature programmer thinking: I learn from
your experience and can better judge appropriate tradeoffs thanks to your lived
and earned wisdom. <strong>From Gee’s analysis of tradeoffs, I hoped to learn and to
be better equipped to analyze my own.</strong> The results might be measurable or gut
feelings, and we would learn from both.</p>

<p>The main article falls flat.</p>

<p>Teed up for story time, we find instead a collection of opinion presented as
fact. This being the internet, of course we find opinion: there must be memories
that inform Gee’s opinions (or else we are reading another cargo-cult piece, and
I want to assume positive intent of Gee, whom I don’t know). We can’t extricate
our opinions from the experiences that shape us. Thus Gee speaks from experience
but shares none of it<sup id="fnref:3"><a href="#fn:3" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>. For example, Gee claims</p>

<blockquote>
  <p>Integrating small changes regularly into your code is usually less painful
than a big merge at the end of a longer period of time.</p>
</blockquote>

<p>This is probably true (“usually”), but comes with none of the analysis that lets
us discern when or why. We’ll examine specific claims later; for now, we are
disappointed in yet another “this is the way” string of paragraphs.</p>

<p>What are we missing? We have a set of opinions which are presumably backed by
the author’s experience and which provide, according to her, some advantage. We
lack</p>

<ul>
  <li>the actual mechanism by which these opinions are practiced, and</li>
  <li>a set of goals or desires against which we can judge the tradeoffs of
different approaches and their effects.</li>
</ul>

<p>We don’t seek analysis to ground our precious art in hard-to-find evidence<sup id="fnref:4"><a href="#fn:4" class="footnote" rel="footnote" role="doc-noteref">2</a></sup>
or to participate in <a href="https://pluralistic.net/2024/10/29/hobbesian-slop/">empiricism
washing</a><sup id="fnref:2"><a href="#fn:2" class="footnote" rel="footnote" role="doc-noteref">3</a></sup>; rather, we aim
to derive from shared opinions lessons we apply to our own situations. We
welcome opinion. For claims of advantage, we insist on analysis in order to
integrate that opinion.</p>

<p>There is other material about the mechanisms of branch- and trunk-based
workflows. <a href="https://git-scm.com/book/en/v2/Distributed-Git-Distributed-Workflows">Pro Git even covers
some</a>, as
does <a href="https://git-scm.com/docs/gitworkflows"><code class="language-plaintext highlighter-rouge">git help workflows</code></a>. Still I want
to mix discussion of tradeoff with implementation mechanism: I find this
clarifies my thoughts.</p>

<p><a id="analysis"></a>We’ll take Gee’s 5 points for trunk-based workflows and
distill both mechanism and tradeoff for branch- and trunk-based workflows. By
the end, you’ll see how I view the wide world of Git use.</p>

<h2 id="speed-and-efficiency">Speed and Efficiency</h2>

<p>Gee claims that trunk-based development means code is integrated more quickly
and more efficiently:</p>

<blockquote>
  <p>This model allows for quicker integrations and fewer merge conflicts. […] It
might seem fast to develop your fixes and improvements on a separate branch
that isn’t impacted by other developers’ changes, but you still have to pay
that cost at some point. Integrating small changes regularly into your code is
usually less painful than a big merge at the end of a longer period of time.</p>
</blockquote>

<p>Here “integrated” code is code that has been combined together to serve some
purpose. Typically it is independently developed code, often for disparate
features or fixes.</p>

<p>Because we lack mechanism, we’re going to take trunk-based development’s
mechanism to mean something like</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>while ! git push; do
    git pull --rebase
done
</code></pre></div></div>

<p>In other words, rebase your single shared branch locally until you are able to
win the push race—after all, if I push first, Git will reject your
non-fast-forward push. (You may merge instead of rebase, but that becomes messy
for no productive reason.)</p>

<p>What is branch-based development’s equivalent workflow? It depends on your team:
the patterns I’ve seen are:</p>
<ul>
  <li>On-demand: Don’t integrate the upstream branch into the topic branch unless
there are conflicts that need resolved or upstream features that the topic
wants. Only then perform a rebase or merge, as desired. Many open-source
projects frown on merging from upstream when it is avoidable: prefer to base
your work on the code that it needs, meaning you will need to rebase if you
need new work.</li>
  <li>Continuous: Integrate the upstream branch constantly, typically via merge. I
see this when “Require branches to be up to date before merging” is enabled
for a repository, and especially when the default (or only) merge strategy is
<a href="/blog/2024/08/02/github-squash/">squashing</a>. In the corporate
environments I’ve seen this in, pushing otherwise unnecessary merges which
clutter the PR is fine since they will disappear anyway.</li>
</ul>

<p>I personally keep to a middle-ground of rebasing on-demand, but more often than
“only when there are conflicts” would suggest: in centralized workflows, I try
to keep branches with PRs based on the latest main branch. In distributed
workflows, I’m less picky about updating until I start a new version of a
branch.</p>

<p>Let’s assume both workflows follow good commit hygiene (small, focused, frequent
commits) aside from debatably-unnecessary merges. Now we can examine tradeoffs:</p>

<ol>
  <li><em>All</em> integrators have to deal with conflicts eventually.</li>
  <li>Trunk-based developers and continuous branch integrators integrate code more
often by nature of the way they operate.</li>
  <li>Assuming trunk-based developers push as soon as they have a working commit
and that they work in a team, they must have to pull frequently. If they
don’t, they push far more frequently than any of their teammates, who <em>do</em>
have to pull frequently. This can be a source of friction. In solo mode, the
push is never rejected, which makes this strategy especially appealing.</li>
  <li>On-demand integrators typically have more commits to rebase or merge when
integrating because of the frequency at which it happens, and we all agree
that more commits means more probability of conflicts.</li>
  <li>On the flip side, making PR review and merge high-priority in a branch-based
workflow means few branches live long enough to deal with complex conflicts.
This might balance out against frequent integrations if a PR is quickly
merged (“near-trunk-based”) without conflicts: on-demand saves some effort
here.</li>
</ol>

<h2 id="greater-code-stability">Greater Code Stability</h2>

<p>Gee claims that trunk-based development</p>

<blockquote>
  <p>encourages frequent commits, which leads to smaller and more manageable
changes. […] In the branching model, large and infrequent merges can introduce
bugs that are hard to identify and resolve due to the sheer size of the
changes.</p>
</blockquote>

<p>Gee argues that more commits (by proxy of “more time”) lead to a higher chance
of conflicts, which I agree with above and for which I suggested a mitigation.
Then she constructs a <a id="strawman"></a><strong>strawman</strong> version of the branching
model: to compare <em>well-run</em> trunk-based development, we should also use
<em>well-run</em> branch-based development, in which ready branches are frequently
reviewed and either merged or rejected<sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">4</a></sup>.</p>

<p>In a well-run branch model, buggy merges are infrequent. Said another way, a
trunk-based developer who hasn’t pulled in a while and creates a large merge
will have the same problems.</p>

<blockquote>
  <p>By frequently pulling in the other developers’ changes, and frequently pushing
small changes of working code, we know the codebase is stable and working.</p>
</blockquote>

<p>This actually depends on stable testing, as Gee writes, and is <strong>independent of
workflow.</strong> In sum, code stability depends more on practices exterior to the
particular workflow than on branch vs. trunk, personal experience and observed
correlations notwithstanding.</p>

<h2 id="enhanced-team-collaboration">Enhanced Team Collaboration</h2>

<p>Gee writes:</p>

<blockquote>
  <p>If you’re all working on your own branches, you are not collaborating. You are
competing. To see who can get their code in fastest. To avoid being stomped on
by someone else’s code changes.</p>
</blockquote>

<p>And yet, as the <code class="language-plaintext highlighter-rouge">while</code> loop demonstrates above, trunk-based developers might
stomp on each other, too. <strong>This is independent of workflow.</strong></p>

<p>This is often a social problem rather than a technical one; that is, I need to
speak with my team about the areas we’re working on and how to organize them.
Resolving that resolves many issues.</p>

<blockquote>
  <p>If you’re all working on the same branch, you tend to have a better awareness
of the changes being made. This approach fosters greater team collaboration
and knowledge sharing. In contrast, branching can create a siloed work
environment where you’re all working independently, leading to knowledge gaps
within the team.</p>
</blockquote>

<p>Conversely, if most of a small team reviews every PR, we still share knowledge.
And for large projects with many subsystems (such as the Rust compiler),
de-siloing knowledge happens via RFC and commit hygiene, not (necessarily) by
reading every pulled commit. <strong>This problem is independent of workflow.</strong></p>

<p>A few actual tradeoffs that are workflow-relevant:</p>

<ol>
  <li>Distributed development teams, whether open source or private, may not be
able to accept trunk-based contributions from community for security or
stability reasons: giving the internet commit rights to your deployment
branch is a bad idea. The Rhombus project is driven primarily by PRs but
cannot for stability, give commit rights to everyone.</li>
  <li>Conversely, small teams with no or few other collaborators can commit
directly and reserve PR workflows for those few outside contributors. The
main Racket repository looks like this (in spite of many external
contributors), as do many other open source projects with active development
communities who don’t mind core devs committing directly.</li>
</ol>

<h2 id="improved-continuous-integration-and-delivery-cicd-practices">Improved Continuous Integration and Delivery (CI/CD) Practices</h2>

<p>Gee claims trunk-based development helps CI/CD because</p>

<blockquote>
  <p>Any failures there are seen and addressed promptly, reducing the risk of nasty
failures. It’s usually easy to track down which changes caused the problem. If
the issue can’t be fixed immediately, you can back [sic] the specific changes
that caused it.</p>
</blockquote>

<p>As may by now be clear, <strong>this is independent of workflow.</strong> Tools like <code class="language-plaintext highlighter-rouge">git
blame</code> and <code class="language-plaintext highlighter-rouge">git bisect</code> are essential to tracking changes, and CI on PRs can
catch them before they are integrated. A CI system would need to warn me loudly
that a push caused a failure for me to notice: with branch-based PRs, I am
frequently looking at the status checks on a GitHub page (for example). That
doesn’t mean a trunk-based CI system couldn’t be noisy! It’s a matter of tooling
and choice, not inherent advantage.</p>

<blockquote>
  <p>It’s at merge (or rebase) time that you start to see any integration issues.
All those tests you were running on your branch “in CI” were not testing any
kind of integration at all.</p>
</blockquote>

<p>This is certainly true and is one of the main arguments for “Require branches to
be up to date before merging.” CI typically also runs on the main branch,
however.</p>

<p>I do have experience with continuous <em>deployment</em> becoming confusing with branch
models: fundamentally it’s a tooling failure, however, because we don’t have
per-PR environments. So to test a deployed PR I might be stomping on some
other PR’s dev or QA environment.</p>

<p>Heavily regulated environments (such as my current workplace) may not be able to
treat each push as a deployment to customers: instead, in some domains we have
to be careful about when we release even if we merge frequently. For our
internal customers, release on push often works fine.</p>

<h2 id="reduced-technical-debt">Reduced Technical Debt</h2>

<p>Gee claims that “merge hell” contributes to technical debt, and I agree: it
creates temptation for quick resolution rather than careful design. All
technical debt is tradeoff, though, and we usually choose to accept some.</p>

<blockquote>
  <p>you may […] accept suggestions from your IDE that resolve the merge but that
you don’t fully understand.</p>
</blockquote>

<p>Not understanding code you produced via tool <strong>is independent of workflow.</strong>
Stop doing that. (Code review <em>may</em> catch this problem but is not a failure-free
safety net. See the “swiss cheese” model of code review.)</p>

<blockquote>
  <p>With trunk-based development, frequent merges and smaller changes make it
easier to manage and reduce the build-up of technical debt.</p>
</blockquote>

<p>Replace “trunk-based” with “branch-based”: does the sentence still ring true? I
think so. <strong>This problem is independent of workflow.</strong> Our assumptions of commit
hygiene support the claim of independence.</p>

<h2 id="conclusion">Conclusion</h2>

<p>See if this sounds right to you:</p>

<blockquote>
  <p>[Software development] requires a mindset, a culture, within the development
team. You need to frequently merge in other developers’ changes into your own
code. You need to commit small changes, frequently, which requires you to only
change small sections of the code and make incremental changes, something
which can be a difficult habit to get used to. Pair programming, comprehensive
automated testing, and maybe code reviews are key practices to helping all the
team to adopt the same approach and culture.</p>
</blockquote>

<p>Gee actually wrote these words about trunk-based development, yet I find they
apply equally to branch-based development! What happened? Presumptuously, I
suspect Gee spent time with branch-based teams that didn’t observe this culture
of commit hygiene and time with trunk-based teams that did. That kind of
anecdata can taint our view of a workflow <em>even when most of the salient
problems are workflow-independent</em>, which <a href="#strawman">leads us to create strawmen out of
poor habits</a>.</p>

<p>I leave you with the following thoughts:</p>
<ul>
  <li>After analysis, the major tradeoffs of either workflow are needed tooling,
conflict resolution, and how to do code review. Most of the rest is a problem
of software development and team culture than a problem of specific choice of
workflow. So <em>pick what works for you</em>.</li>
  <li>Perhaps the true question we should be asking is: what are the tradeoffs of
following or not following good commit hygiene? Most engineers have some
intuition for these tradeoffs, yet we all find large variety in adherence to
commit hygiene. My analysis in this article suggests that good commit hygiene
undergirds most of the advantages Gee ascribes to trunk-based development.
Maybe that’s the real change we need to convince people to make?</li>
  <li>It <em>may</em> be the case that trunk-based development acts as a stronger forcing
function for well-tested code, commit hygiene, and all the rest. Gee makes
some claims to this effect, and I cannot personally evaluate them. I have seen
struggling branch-based teams who adopt better test and commit hygiene come to
benefit—the poster children of good branch-based development would be Git,
Vim, Rust, and similar projects. Which style is more likely to force what
practices is a very different article and set of claims, though!<sup id="fnref:5"><a href="#fn:5" class="footnote" rel="footnote" role="doc-noteref">5</a></sup></li>
</ul>

<p><a id="postscript"></a>PS Gee later writes in comments:</p>

<blockquote>
  <p>It all comes down to discipline, and the team. For me, I prefer to see
IMMEDIATELY if there are any problems caused by any developer’s commit. I
prefer people not to commit if the trunk is red. I prefer people to fix
problems AS SOON as they occur, and if they cannot be fixed inside 5 minutes
(say), back out that commit and fix it locally. I prefer to work on the same
codebase as everyone else, and not some isolated branch, even if that branch
is only a day old.</p>
</blockquote>

<p>This is what I expected coming in: “my preference is X, but it all comes down to
good hygiene.” I would still have preferred to see what “back out the commit”
means, though I assume it’s some version of <code class="language-plaintext highlighter-rouge">git revert</code>. Even here, “as soon as
they occur” can still be “when PR tests catch the problem.”</p>

<p>Another commenter writes “even if you only ever work on main you absolutely do
have a local branch that is separate from the remote branch,” which is an
insightful perspective: with Git’s model, even centralized workflows don’t force
you to synchronize for every change. There is always more than one branch if you
have a remote.</p>

<p>PPS A future post will cover my own workflows in various setups and
situations—keep an eye on the RSS feed for that!</p>

<h2 id="notes">Notes</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:3">
      <p>See <a href="#postscript">the postscript</a> for a shift: in the comments, we see
more of Gee’s thought process. <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4">
      <p>Though evidence is certainly welcome to inform tradeoffs. See for example
<a href="/blog/2024/09/14/benchmarking-pict-equality-pt-2/">performance comparisons</a> or <a href="https://www.hillelwayne.com/talks/ese/">What we know we
don’t know</a>. <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>See also <a href="https://locusmag.com/2021/05/cory-doctorow-qualia/">Cory Doctorow’s essay on Qualia</a> <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:1">
      <p>Rejected branches that need follow up work to become ready are treated as
new versions even when they share commits; in other words, think
email-driven “v1/2/3” workflows even when working with GitHub’s UI and
rebases. On GitHub, you might also close a PR and start a new one if the new
work is significantly different from the old, whether you rebase or not. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5">
      <p>Evaluating them has to be sensitive to seniority, too: if you only have
senior engineers in your trunk pool and juniors in your branch pool, well,
that’s the correlation you measure. And I suspect that many of us that are
in poor branch-based communities now are surrounded by juniors in corporate
environments that don’t reward well the teams who spend time on these
considerations; when we move to a pod of seniors that have already adopted
the baseline assumptions (commit hygiene, etc.), whether they choose
trunk-based or branch-based development, the model surely shines. <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

</div>
<hr/>
<h4>Tags:</h4>
<ul class="tags">
  
    <li>
      <a href="https://benknoble.github.io/tags#git" class="tag">
        git
      </a>
    </li>
  
</ul>

<div id="post-categories">
  <h4>Categories:
  
    <a href="/categories/#blog">Blog</a>
    
  
  </h4>
</div>

<div id="disqus_thread"></div>
<div class="load-comments" onclick="load_comments(this)">Load Comments</div>
<script>
  var disqus_shortname = 'https-benknoble-github-io';
  var disqus_config = function () {
    this.page.url = "https://benknoble.github.io/blog/2024/11/11/git-branch-trunk-perspective/";
    this.page.identifier = "/blog/2024/11/11/git-branch-trunk-perspective";
  };

  function load_comments(div) {
    var d = document, s = d.createElement('script');
    s.type = 'text/javascript';
    s.async = true;
    s.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    div.parentNode.removeChild(div)
  };
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


<div id="post-navigation">
  
  <span id="previous">
    <a href="https://benknoble.github.io/blog/2024/10/04/copy-range-diff/"
      title="Copying a git-range-diff to GitHub">
      Previous</a>
  </span>
  
  
  <span id="next">
    <a href="https://benknoble.github.io/blog/2024/11/15/til-range-diff/"
       title="Tip: use symmetric differences with git-range-diff">
      Next</a>
  </span>
  
</div>
<div id="back-to-posts">
  <a href="/categories/#perspective-on-software-development-models">
    Back to posts</a>
</div>

    </section>
    <footer>
<hr/>
  <ul>
    
    <li>
      <a href="https://benknoble.github.io/">Home</a>
    </li>
    
    <li>
      <a href="https://benknoble.github.io/contact/">Contact</a>
    </li>
    
    <li>
      <a href="https://benknoble.github.io/sitemap.xml">Sitemap</a>
    </li>
    
    <li>
      <a href="https://benknoble.github.io/feed.xml">RSS Feed</a>
    </li>
    
    <li>
      <a href="https://benknoble.github.io/colophon/">Colophon</a>
    </li>
    
    <li>
      <a href="https://github.com/benknoble/benknoble.github.io/blob/master/LICENSE">Copyright D. Ben Knoble <script type='text/javascript'>document.write(new Date().getFullYear())</script></a>
    </li>
    
    <li>
      <p xmlns:cc="http://creativecommons.org/ns#" ><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/?ref=chooser-v1" target="_blank" rel="license noopener noreferrer" style="display:inline-block;">CC BY-NC-SA 4.0<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1" alt=""><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1" alt=""><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/nc.svg?ref=chooser-v1" alt=""><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1" alt=""></a></p>
    </li>
  </ul>
</footer>

    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    <script>
      (function() {
        var script = document.createElement('script');
        window.counter = 'https://benknoble_github_io.goatcounter.com/count'
        script.async = 1;
        script.src = '//gc.zgo.at/count.js';

        var ins = document.getElementsByTagName('script')[0];
        ins.parentNode.insertBefore(script, ins)
      })();
    </script>
  </body>
</html>
