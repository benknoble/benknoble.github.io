<!DOCTYPE html>
<html>
  <head>
  <title>Junk Drawer : Re: How Did Perl Lose Ground to Bash?</title>
  <meta charset='utf-8'>
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  <!-- link to main stylesheet -->
  <link rel="stylesheet" type="text/css" href="https://benknoble.github.io/assets/css/styles.css" media="screen">

  <script src="/assets/js/scale.fix.js"></script>
  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" >
  </script>

  <link rel="apple-touch-icon" sizes="180x180" href="/assets/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/assets/img/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">

  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link type="application/atom+xml" rel="alternate" href="https://benknoble.github.io/feed.xml" title="Junk Drawer" />
</head>

  <body>
    <header>
  <h1>
  <a href="https://benknoble.github.io/">
  <img src='/assets/img/logo.png' alt='Junk Drawer Logo' width=32 height=32> Junk Drawer</a></h1>
  <p>For all those little papers scattered across your desk</p>
</header>

    <section>
      <p>
      I stand for the Constitution, for due process, and for community that
      takes care of each other.
      </p>
      <nav>
  <ul>
    
    <li class="">
      <a href="https://benknoble.github.io/about/">About</a>
    </li>
    
    <li class="">
      <a href="https://benknoble.github.io/categories/">Posts</a>
    </li>
    
    <li class="">
      <a href="https://benknoble.github.io/workshops/">Workshops</a>
    </li>
    
    <li class="">
      <a href="https://benknoble.github.io/papers/">Papers</a>
    </li>
    
    <li class="">
      <a href="https://benknoble.github.io/writings/">Writings</a>
    </li>
    
    <li class="">
      <a href="https://benknoble.github.io/reading/">Reading List</a>
    </li>
    
  </ul>
</nav>

      <h1>Re: How Did Perl Lose Ground to Bash?</h1>
      <p class="meta"><span class="authors">
  
  
    D. Ben Knoble
  
</span>
 on 27 Sep 2019 in Blog</p>
<div id="post">
  <p>Spoiler: Because I don’t <em>need</em> or <em>use</em> Perl everyday</p>

<h2 id="original-post"><a href="https://www.reddit.com/r/perl/comments/d2yix0/how_did_perl_lose_ground_to_bash/?utm_source=feedburner&amp;utm_medium=feed&amp;utm_campaign=Feed%3A+PerlWeekly+%28Perl+Weekly+newsletter%29">Original post</a></h2>

<p>This was the original post as accessed on the 26th of September, 2019. All
quotes are from that day, approximately 22:30 EDT.</p>

<blockquote>
  <p>Setting aside Perl vs. Python for the moment, how did Perl lose ground to Bash?
It used to be that Bash scripts often got replaced by Perl scripts because Perl
was more powerful. Even with very modern versions of Bash, Perl is much more
powerful.</p>

  <p>The Linux Standards Base (LSB) has helped ensure that certain tools are in
predictable locations. Bash has gotten a bit more powerful since the release of
4.x, sure. Arrays, handicapped to 2-D arrays, have improved somewhat. There is a
native regex engine in Bash 3.x, which admit is a big deal. There is also
support for hash maps.</p>

  <p>This is all good stuff for Bash. But, none of this is sufficient to explain why
Perl isn’t the thing you learn after Bash, or, after Bash and Python; take your
pick. Thoughts?</p>

  <p>—u/s-romojosa</p>
</blockquote>

<h3 id="a-first-glance">A first glance</h3>

<p>It may be true that the core language of Perl is more powerful (with or without
CPAN)—there are more language features, more powerful constructs, etc. Bash,
on the other hand, is relatively simple at its core. But to restrict Bash to
while loops and a pipeline includes its biggest weakness and its biggest
strength, while ignoring practically every other good thing about it.</p>

<p>I’ll come back to the weakness, but I want to clarify: pipelines are Bash’s
strength. They are function composition. They are what enable me to rapidly
filter and process data in whichever way I like—wait, no, that’s not right.
<em>Pipelines</em> enable me to combine tools! That’s function composition. But what
would a <code class="language-plaintext highlighter-rouge">|</code> be without a tool on either side?</p>

<p>To ignore that Bash is a shell fundamentally built to compose <em>other tools</em>
(<code class="language-plaintext highlighter-rouge">grep(1)</code>, <code class="language-plaintext highlighter-rouge">sed(1)</code>, and <code class="language-plaintext highlighter-rouge">awk(1)</code> among the most popular, but <code class="language-plaintext highlighter-rouge">cut(1)</code> and
<code class="language-plaintext highlighter-rouge">paste(1)</code> and even <code class="language-plaintext highlighter-rouge">jq(?)</code> too)—in other words, to ignore that Bash is very
nearly a <em>meta</em>-language, is to ignore its true power.</p>

<h3 id="some-nits">Some nits</h3>

<blockquote>
  <p>Arrays, handicapped to 2-D arrays, have improved somewhat</p>
</blockquote>

<p>What is the author talking about? I’ve never seen a 2D array in Bash. The array
types are “one-dimensional indexed and associative” (<code class="language-plaintext highlighter-rouge">bash(1)</code>).</p>

<blockquote>
  <p>[…] hash maps</p>
</blockquote>

<p>They’re called associative arrays—I’m concerned the author doesn’t understand
Bash! To be fair, I barely understand the deepest parts of Perl. But I
understand hashes in Perl, and would expect someone asking this question to
understand associative arrays in Bash. Core language features…</p>

<blockquote>
  <p>[…] native regex engine in Bash 3.x, which admit [sic] is a big deal</p>
</blockquote>

<p>Actually, it is not that big a deal. The first three tools I mentioned all deal
in regex. So do many more. Bash’s native engine is good for its capture groups:
but then, I should ask you—if you find yourself needing capture groups, what
are the chances you’re going to process the captured data later? And what are
the odds there is a better, perhaps more efficient, solution—one which uses a
pipeline?</p>

<p>(Remember <a href="/blog/2019/08/14/cstat-efficiencies/">my post</a> about
pipelines?)</p>

<h3 id="sample-of-responses">Sample of responses</h3>

<p>I’m going to take a moment to address some of the responses in the same vein as
I did with the OP, because I think some of them missed at least part of the
mark.</p>

<blockquote>
  <p>Because Perl has suffered immensely in the popularity arena and is now viewed
as undesirable. It’s not that Bash is seen as an adequate replacement for
Perl, that’s where Python has landed.</p>

  <p>—u/oldmanwillow21</p>
</blockquote>

<p>I don’t think this fully explains why <em>I</em> don’t use Perl. I’ve never needed to.</p>

<p>Let me give you a simple problem: write a function that, given some data
(however you want input: stdin, arguments, whatever), computes the frequency of
each piece. That is, compute (return, output, etc.) a mapping between the
elements of the data and the count of how many times that element occurred.</p>

<p>Go ahead. I’ll wait.</p>

<p>In bash, it’s one line: <code class="language-plaintext highlighter-rouge">frequency() { sort | uniq -c ; }</code>. Hell, just for fun,
I sorted the results again: <code class="language-plaintext highlighter-rouge">frequency_sorted() { sort | uniq -c | sort -g ; }</code>.</p>

<p>It’s simple. It’s understandable. It’s built on composition.</p>

<p>I’m sure there’s at least one language where it amounts to <code class="language-plaintext highlighter-rouge">data.counts()</code>, but
can I pipe in anything I want from the shell to it?</p>

<p>Further examples:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># most recent commands</span>
recent<span class="o">()</span> <span class="o">{</span>
  <span class="nb">history</span> | <span class="nb">cut</span> <span class="nt">-c8-</span> | <span class="nb">cut</span> <span class="nt">-d</span><span class="s2">" "</span> <span class="nt">-f1</span> | frequency_sorted | <span class="nb">sort</span> <span class="nt">-rn</span> | <span class="nb">head</span>
<span class="o">}</span>

<span class="c"># mode</span>
mode<span class="o">()</span> <span class="o">{</span> frequency_sorted | <span class="nb">head</span> <span class="nt">-n</span> 1 <span class="p">;</span> <span class="o">}</span>
</code></pre></div></div>

<p>It would have taken me longer to write <code class="language-plaintext highlighter-rouge">frequency</code> in Perl than all three of
these together, and then I’d still have to figure out how to get my data into
it.</p>

<p>So I use Bash because it does exactly what I need—I don’t need to reach for
fancy objects to do this kind of manipulation.</p>

<p><strong>Please post your Perl (or other) attempts in the comments.</strong></p>

<blockquote>
  <p>I’d add to this, it’s because no real competitor has emerged for Bash.</p>

  <p>—u/Grinnz</p>
</blockquote>

<p>Doubtful: what about Zsh, Fish, and the host of others? Again, I don’t think
this is the real reason Bash is popular.</p>

<p>At least one point remains: Bash was default on macOS until recently. It is
(was?) default on other Linux distros as well.</p>

<blockquote>
  <p>How did Perl5 lose ground to anything else?
Thusly</p>
  <ul>
    <li>“thou must use Moose for everything” -&gt; “Perl is too slow” -&gt; rewrite in
Python because the architect loves Python -&gt; Python is even slower -&gt;
architect shunned by the team and everything new written in Go, nobody dares
to complain about speed now because the budget people don’t trust them -&gt;
Perl is slow</li>
    <li>“globals are bad, singletons are good” -&gt; spaghetti -&gt; Perl is unreadable</li>
    <li>“lets use every single item from the gang of four book” -&gt; insanity -&gt; Perl
is bad</li>
    <li>“we must be more OOP” -&gt; everything is a faux object with everything else as
attributes -&gt; maintenance team quits and they all take PHP jobs, at least
the PHP people know their place in the order of things and do less
hype-driven-development -&gt; Perl is not OOP enough</li>
    <li>“CGI is bad” -&gt; app needs 6.54GB of RAM for one worker -&gt; customer refuses
to pay for more RAM, fires the team, picks a PHP team to do the next version
-&gt; PHP team laughs all the way to the bank, chanting “CGI is king”</li>
  </ul>

  <p>—u/emilper</p>
</blockquote>

<p>Aha, so emilper wants to talk about larger systems? Systems where we need
objects and classes and design patterns? I’m not saying you <em>can’t</em> do this in
Perl. But why not do it in a language where this stuff is baked in? OOP in Perl
is kludgy—it would be in Bash too, if someone did it. And we’d all say “Wow,
that’s cool, but I can’t use it because no one would understand what the hell I
was doing or why.” We’d go back to Java, C#, Smalltalk, Ruby, Python, or a Lisp
or ML or Haskell. And we’d be happier. Because those languages are fundamentally
designed to do larger systems, better.</p>

<p>I’m not writing OOP, CGI, or large systems in Bash. I’d challenge anyone who is
to rethink their design.</p>

<p>My longest (in lines) scripts in my Dotfiles are:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># wc -l $(ack -f --shell) | sort -rg | head</span>
    2009 total                            <span class="c"># total lines</span>
     196 links/bash/PS1.bash              <span class="c"># builds my prompt</span>
     193 links/bashrc                     <span class="c"># part of my startup config</span>
     123 links/bin/git-overwritten        <span class="c"># oh, an actual script that does some text processing</span>
     102 links/bin/java-update-mfile      <span class="c"># and another!</span>
</code></pre></div></div>

<p>The real scripts are on the order of 100 lines.</p>

<p>The smallest?</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># wc -l $(ack -f --shell) | sort -g | head</span>
       2 links/bash/linux/clipboard.bash
       4 links/bash/jobs.bash
       5 links/git_template/hooks/post-checkout
       5 links/git_template/hooks/post-commit
       5 links/git_template/hooks/post-merge
       6 links/bash/overrides.bash
       7 links/bash/sysadmin.bash
       7 links/git_template/hooks/post-rewrite
       8 links/bash/mac/sysadmin.bash
      10 links/bin/brew-superclean
</code></pre></div></div>

<p>Just, wow. Now, let’s take a look at the frequency of lines. The format is
(count lines):</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># wc -l $(ack -f --shell) | G -v 'total' | fields 1 | frequency</span>
   1 10
   1 102
   1 12
   1 123
   1 13
   1 15
   1 17
   1 193
   1 196
   1 2
   1 20
   1 24
   1 26
   1 27
   1 29
   1 32
   1 4
   1 43
   1 45
   1 49
   1 50
   1 59
   1 6
   1 62
   1 8
   1 82
   1 85
   1 86
   1 98
   2 14
   2 16
   2 28
   2 68
   2 7
   3 11
   3 18
   3 41
   3 5
</code></pre></div></div>

<p>(<code class="language-plaintext highlighter-rouge">G</code> is a <code class="language-plaintext highlighter-rouge">grep(1)</code> function, and <code class="language-plaintext highlighter-rouge">fields</code> I wrote about previously.)</p>

<p>Anyone want to build a histogram for me? Say, bucketed by 10?</p>

<p><strong>Edit 28th September</strong>: I got close with <code class="language-plaintext highlighter-rouge">awk(1)</code> (<code class="language-plaintext highlighter-rouge">A</code>), and formatted by
(lines, count):</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># wc -l $(ack -f --shell) | G -v 'total' | fields 1 |</span>
<span class="c">#   A '{ printf "%d\n", sprintf("%1.0e", $0) }' |</span>
<span class="c">#   frequency | fields 2 1 | sort -g |</span>
<span class="c">#   A '{ printf "%d\t", $1</span>
<span class="c">#        for (i=0;i&lt;int($2);i++) printf "*"</span>
<span class="c">#        printf "\n" }'</span>
2       <span class="k">*</span>
4       <span class="k">*</span>
5       <span class="k">***</span>
6       <span class="k">*</span>
7       <span class="k">**</span>
8       <span class="k">*</span>
10      <span class="k">********</span>
20      <span class="k">*********</span>
30      <span class="k">******</span>
40      <span class="k">*****</span>
50      <span class="k">**</span>
60      <span class="k">**</span>
70      <span class="k">**</span>
80      <span class="k">**</span>
90      <span class="k">*</span>
100     <span class="k">***</span>
200     <span class="k">**</span>
</code></pre></div></div>

<p>(With judicious function definitions, I got this down to
<code class="language-plaintext highlighter-rouge">wc -l $(ack -f --shell) | G -v 'total' | fields 1 | nearest_ten | frequency | histogram_f</code>
.)</p>

<p>To be clear, my argument is that emilper presents good reasons against Perl in
large systems. But not against Perl v. Bash.</p>

<blockquote>
  <p>It baffles me the most because the common objection to Perl is legibility.
Even if you assume that the objection is made from ignorance - i.e. not even
having looked at some Perl to gauge its legibility - the nonsense you see in a
complex bash script is orders of magnitude worse!</p>

  <p>Not to mention its total lack of common language features like first-class data
and… Like, a compiler…</p>

  <p>I no longer write bash scripts because it takes about 5 lines to become
unmaintainable.</p>

  <p>—u/Altreus</p>
</blockquote>

<p>Bad programmers do not a bad language make. We make fun of PHP’s design
decisions, and say it’s a bad language. Bash has its warts, like all languages,
but fundamentally it is well designed, and small. It’s a shell: if it is terse,
it is for efficiency. The knowledgeable Bash programmer has a handful of trusty
concepts that he wields like knives, cutting programs this way and that until
they do what is required.</p>

<p>Bash can be readable. Isolate functions. Compose pipelines. Eliminate duplicate
code where reasonable. Use good names. <code class="language-plaintext highlighter-rouge">set -euo pipefail</code> so you don’t shoot
yourself in the foot.</p>

<p>The language has idioms, like any other. Learn them. Bash is maintainable: just
look at my line counts above!</p>

<p>First-class data? Bash is too meta for that: it permits while read loops, but
most of the time another tool does that for you. Compose tools to act on data!</p>

<p>A compiler!? Forget not that Bash has it’s origins as a <em>shell</em>—it is by
nature interactive and must be interpreted. You don’t care that Perl is
interpreted… it’s all just compiling on-the-fly.</p>

<p>Don’t bash Bash because you have seen poor code.</p>

<blockquote>
  <p>There’s a long history of bad code written by mediocre developers who became
the only one who could maintain the codebase until they no longer worked for
the organization. The next poor sap to go in found a mess of a codebase and
did their best to not break it further. After a few iterations, the whole
thing is ready for /dev/null and Perl gets the blame […]</p>

  <p>—u/codon011</p>
</blockquote>

<p>See above: Bash suffers from the same appearance. <strong>Bash is not scary.</strong></p>

<p>If you are a Bash programmer, for the love of God, don’t make it scary. Do the
sane thing and write legible scripts. I don’t care what you do interactively;
that can be gibberish. Scripts must be maintained.</p>

<p>And then there’s this person, who gets it:</p>

<blockquote>
  <p>To be fair, wrapping a Perl script around something that’s (if I read your
comment right) just running SCP is adding a pointless extra layer of
complexity anyway.</p>

  <p>It’s a matter of using the best tool for each particular job, not just sticking
with one. My own ~/bin directory has a big mix of Perl and pure shell, depending
on the complexity of the job to be done.</p>

  <p>—u/beermad</p>
</blockquote>

<p><em>This</em> is why I don’t reach for Perl. I don’t need Perl to scp. I need <code class="language-plaintext highlighter-rouge">scp(1)</code>,
damnit.</p>

<p>I have written one real Perl thing (<a href="/release/2019/07/15/plink-release/">Plink</a>). It was just complex enough to be
interesting. But if I’m doing that frequency thing above? Bash, baby.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Bash is all about composing tools. It can be bent into other things, but
ultimately it prefers to have a meta-language feel, composing other languages to
do what they do best.</p>

<p>Bash programmers are polyglots. We reach for a Perl or Python or Ruby one-liner
when necessary, but often accomplish the same in <code class="language-plaintext highlighter-rouge">awk(1)</code> or <code class="language-plaintext highlighter-rouge">grep(1)</code> or
<code class="language-plaintext highlighter-rouge">sed(1)</code>. I’ve even used <code class="language-plaintext highlighter-rouge">ed(1)</code> in a script before. Each of these tools has a
language that I learn and use. Others have flags and options—a unique
language.</p>

<p>The language of Bash is the language of its tools, with a few syntactic niceties
on top to make functions out of functions (<code class="language-plaintext highlighter-rouge">|</code>) and do simple control flow.</p>

<p>There’s a reason almost every language provides a convenient way to “shell
out”—it’s too powerful not to.</p>

</div>
<hr/>
<h4>Tags:</h4>
<ul class="tags">
  
    <li>
      <a href="https://benknoble.github.io/tags#perl" class="tag">
        perl
      </a>
    </li>
  
    <li>
      <a href="https://benknoble.github.io/tags#shell" class="tag">
        shell
      </a>
    </li>
  
    <li>
      <a href="https://benknoble.github.io/tags#prog-langs" class="tag">
        prog-langs
      </a>
    </li>
  
</ul>

<div id="post-categories">
  <h4>Categories:
  
    <a href="/categories/#blog">Blog</a>
    
  
  </h4>
</div>

<div id="disqus_thread"></div>
<div class="load-comments" onclick="load_comments(this)">Load Comments</div>
<script>
  var disqus_shortname = 'https-benknoble-github-io';
  var disqus_config = function () {
    this.page.url = "https://benknoble.github.io/blog/2019/09/27/perl-v-bash/";
    this.page.identifier = "/blog/2019/09/27/perl-v-bash";
  };

  function load_comments(div) {
    var d = document, s = d.createElement('script');
    s.type = 'text/javascript';
    s.async = true;
    s.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    div.parentNode.removeChild(div)
  };
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>


<div id="post-navigation">
  
  <span id="previous">
    <a href="https://benknoble.github.io/blog/2019/09/11/fields/"
      title="The Fields Extracter You Always Wanted">
      Previous</a>
  </span>
  
  
  <span id="next">
    <a href="https://benknoble.github.io/blog/2019/10/21/wakeup1/"
       title="5am Wake-up Call: Day 1">
      Next</a>
  </span>
  
</div>
<div id="back-to-posts">
  <a href="/categories/#re-how-did-perl-lose-ground-to-bash">
    Back to posts</a>
</div>

    </section>
    <footer>
<hr/>
  <ul>
    
    <li>
      <a href="https://benknoble.github.io/">Home</a>
    </li>
    
    <li>
      <a href="https://benknoble.github.io/contact/">Contact</a>
    </li>
    
    <li>
      <a href="https://benknoble.github.io/sitemap.xml">Sitemap</a>
    </li>
    
    <li>
      <a href="https://benknoble.github.io/feed.xml">RSS Feed</a>
    </li>
    
    <li>
      <a href="https://benknoble.github.io/colophon/">Colophon</a>
    </li>
    
    <li>
      <a href="https://github.com/benknoble/benknoble.github.io/blob/master/LICENSE">Copyright D. Ben Knoble</a>
    </li>
    
    <li>
      <a href="https://www.goatcounter.com">No personal information collected</a>
    </li>
    
    <li>
      <p xmlns:cc="http://creativecommons.org/ns#" ><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/?ref=chooser-v1" target="_blank" rel="license noopener noreferrer" style="display:inline-block;">CC BY-NC-SA 4.0<img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1" alt=""><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1" alt=""><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/nc.svg?ref=chooser-v1" alt=""><img style="height:22px!important;margin-left:3px;vertical-align:text-bottom;" src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1" alt=""></a></p>
    </li>
  </ul>
</footer>

    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    <script>
      (function() {
        var script = document.createElement('script');
        window.counter = 'https://benknoble_github_io.goatcounter.com/count'
        script.async = 1;
        script.src = '//gc.zgo.at/count.js';

        var ins = document.getElementsByTagName('script')[0];
        ins.parentNode.insertBefore(script, ins)
      })();
    </script>
  </body>
</html>
